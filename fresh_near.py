# -*- coding: utf-8 -*-
"""FRESH-near.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U459EOojmJD6mSVHB_DYoEThV9dzhUZh
"""

import random
import math
import time

L=1000 # size of grid L x L
class Node:
  def __init__(self, node_id, N):
    self.id = node_id
    self.x = random.random()*L
    self.y = random.random()*L
    self.x_next = random.random()*L
    self.y_next = random.random()*L
    self.steps = random.randrange(1,10) # δεν ειναι ακριβως ταχυτητα, ειναι μαλλον "αντιστροφη ταχυτητα". Δειχνει σε ποσα χρονικα slots θα μετακινηθει ο κομβος απο τη θεση (x_i,y_i) στη θεση (x_(i+1), y_(i+1))
    self.velocity_x = (self.x_next - self.x) / self.steps
    self.velocity_y = (self.y_next - self.y) / self.steps
    self.pause_remaining = 5  # It shows for how long I will be stopped in my current destination, initial thinking time is 5 time slots
    self.pause_flag = False # It shows whether I m stopped right now or not
    self.vector = [-1] * N # encounter vector of each node
    self.neighbors = set() # my neighbors at the moment                                             

  def find_dist(self, node):
    dist=math.sqrt((self.x-node.x)**2 + (self.y-node.y)**2)
    return dist
  
  def find_neigh(self, ring, time):
    self.neighbors=set()
    for i in ring:
      if i.id==self.id:
        self.vector[i.id]=time
        continue
      dist=self.find_dist(i)
      if dist<=149:
        self.neighbors.add(i)
        self.vector[i.id]=time

class Packet:
  def __init__(self, packet_id, ring):
    self.id = packet_id
    self.source = random.choice(ring)
    self.destination = random.choice(ring)
    while self.source == self.destination:
      self.destination = random.choice(ring)
    self.custod = self.source
    self.delivered = False #  Whether it has been delivered or not
    self.flag = False # a flag that indicates if we have examined this packet in this round
    self.AoI = 0

def search(node,packet,radius,ring,version):
  if radius > 1000:
    return False
  my_list=[]
  for i in ring:
    if i.id == node.id:
      continue
    else:
      if node.find_dist(i) <= radius:
        my_list.append(i)
  max_value=node.vector[packet.destination.id]
  kaliteros=-2
  for k in my_list:
    if k.vector[packet.destination.id] > max_value:
      max_value = k.vector[packet.destination.id]
      kaliteros = k
      if version == 2:
        break
  if kaliteros != -2:
    #print(f"I am node {node.id} and I give packet {packet.id} to my best near node {kaliteros.id}")
    packet.custod = kaliteros
    packet.flag = True
    if kaliteros==packet.destination:
      packet.delivered = True
      return True
    return False
  else:
    #print(f"I am node {node.id} and didn't find something better than me for packet {packet.id} so i will try again with double radius")
    return search(node,packet,2*radius,ring,version)

max_AoI = 0
arxi=time.time()
success = 0 # number of successful deliveries so far 
id = 0 #  id of the next packet to be generated
ring=[]
for i in range(100):
  node = Node(i, 100)
  ring.append(node)
packets = set()
times=0
while (times<=5000):
  print(f"timestamp: {times}")
  # generation of new packets
  p = random.randint(1, 3)
  while p > 0:
    new = Packet(id, ring)
    packets.add(new)
    id= id +1
    p = p-1
  '''
  for i in packets:
    if i.delivered == False:
      print(f"Packet {i.id} has source {i.source.id}, destination {i.destination.id} and is now in {i.custod.id}")
    else:
      print(f"Packet {i.id} has been delivered or dropped")
  '''
  #simulation of random waypoint mobility model
  for i in ring:
    if i.pause_flag == False:
      i.x = i.x + i.velocity_x * 1
      i.y = i.y + i.velocity_y * 1
      i.steps = i.steps -1
      if i.steps == 0: #  I reached my destination, so I will now stop here for 5 time slots and I will find my new destination
        i.pause_flag = True
        i.x_next = random.random()*L
        i.y_next = random.random()*L
        i.steps = random.randrange(1,10) 
        i.velocity_x = (i.x_next - i.x) / i.steps
        i.velocity_y = (i.y_next - i.y) / i.steps
    else:
      i.pause_remaining = i.pause_remaining - 1
      if i.pause_remaining == 0:
        i.pause_flag = False
        i.pause_remaining = 5
  for i in ring:
    i.find_neigh(ring, times)
    #print(f"I am node {i.id} and my position is ({i.x}, {i.y}), I want to go to ({i.x_next}, {i.y_next}) and my velocity is ({i.velocity_x}, {i.velocity_y})")
  for i in ring:
    #print(f"I am node {i.id} and my neighbors right now are {list(l.id for l in i.neighbors)}")
    #print(f"I am node {i.id} and my encounter vector is {i.vector}")
    lista=[]
    for j in packets:
      if j.custod == i and j.delivered == False and j.flag == False:
        lista.append(j)
    if len(lista) == 0:
      continue
    else:
      best = random.choice(lista)
      result=search(i,best,10,ring,1)
      if result==True:
        success = success + 1
  for i in packets:
    if i.delivered == False:
      i.AoI = i.AoI + 1
    if i.flag == True:
      i.flag = False
  times=times+1
total = 0
for i in packets:
  total = total + i.AoI
  if i.AoI > max_AoI:
    max_AoI = i.AoI
mean = total / len(packets)
print(f"Total number of packets generated in the simulation: {id}")
print(f"Total number of successfull transmissions: {success}")
print(f"Total number of remaining packets in the network: {id-success}")
telos=time.time()
print(f"Execution time: {telos -arxi}")
print(f"Throughput is {success/id}")
print(f"Mean AoI is {mean}")
print(f"Maximum AoI is {max_AoI}")